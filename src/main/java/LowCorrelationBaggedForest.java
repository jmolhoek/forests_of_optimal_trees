import Data.DataSet;
import Data.Record;
import org.javatuples.Pair;

import java.util.ArrayList;
import java.util.concurrent.ThreadLocalRandom;

/**
 * Random Forest that applies bagging. Each next tree is generated by using the altered MurTree algorithm to get all optimal trees.
 * From this list, the tree with the lowest correlation with the existing trees is picked.
 */
public class LowCorrelationBaggedForest extends Forest {
    private final ArrayList<WeightedTree> trees;
    private final Classifier tieResolver;

    /**
     * Constructs the forest.
     * @param d training data
     * @param numberOfTrees number of trees
     * @param treeBuilder builder for optimal trees (sort of carrier for the depth parameter)
     * @param tieResolver classifier to resolve ties
     * @throws InterruptedException if interrupted (e.g. by time-out)
     */
    public LowCorrelationBaggedForest(DataSet d, int numberOfTrees, MurTreeBuilder treeBuilder, Classifier tieResolver)
            throws InterruptedException {
        this.trees = new ArrayList<>(numberOfTrees);
        this.tieResolver = tieResolver;

        DataSet initBootstrap = d.getBootstrap();
        DecisionTree initTree = treeBuilder.build(initBootstrap);
        this.addTree(initTree);

        for (int i = 0; i < numberOfTrees - 1; i++) {
            DataSet bootstrap = d.getBootstrap();

            ArrayList<DecisionTree> optimalTrees;

            try {
                Pair<ArrayList<DecisionTree>, Double> res = AllMurTreeBuilder.optimalTrees(bootstrap, treeBuilder.getDepth());
                optimalTrees = res.getValue0();
            }
            catch (Infeasible e) {
                e.printStackTrace();
                return;
            }

            ArrayList<DecisionTree> minCorrelationTrees = new ArrayList<>();
            double minCorrelation = Double.MAX_VALUE;
            int treeDuplicates = 0;

            for (DecisionTree t : optimalTrees) {
                try {
                    double correlation = correlation(trees, t, d);
                    if (correlation <= minCorrelation) {
                        if (correlation < minCorrelation) minCorrelationTrees.clear();
                        minCorrelation = correlation;
                        minCorrelationTrees.add(t);
                    }
                }
                catch (TreeAlreadyExists e) {
                    treeDuplicates++;
                }
            }

            if (treeDuplicates == optimalTrees.size()) {
                continue;
            }

            this.addTree(minCorrelationTrees.get(ThreadLocalRandom.current().nextInt(minCorrelationTrees.size())));
        }
    }

    private synchronized void addTree(DecisionTree t) {
        trees.add(new WeightedTree(t, 1.0));
    }

    public static double correlation(ArrayList<WeightedTree> trees, DecisionTree tree, DataSet d) throws TreeAlreadyExists {
        double correlation = 0.0;

        for (WeightedTree t : trees) {
            int agreement = agreement(t.getTree(), tree, d);

            if (agreement == d.getSize()) throw new TreeAlreadyExists();

            correlation += agreement;
        }

        return correlation / d.getSize();
    }

    public static int agreement(DecisionTree t1, DecisionTree t2, DataSet d) {
        int agreement = 0;
        for (int i = 0; i < d.getSize(); i++) {
            Record r = d.getEntry(i);
            if (t1.classify(r) == t2.classify(r)) agreement++;
        }
        return agreement;
    }

    @Override
    public int classify(Record record) {
        return Classifier.majorityVote(trees, record, tieResolver);
    }

    @Override
    public int numberOfTrees() {
        return trees.size();
    }
}
