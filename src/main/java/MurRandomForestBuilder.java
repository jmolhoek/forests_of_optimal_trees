import Data.DataSet;

import static org.apache.commons.math3.util.ArithmeticUtils.pow;

/**
 * Allows defining the desired structure and behaviour of the Forest without actually building the forest yet.
 * The desired forest is generated by calling the build method, given the training data.
 */
public class MurRandomForestBuilder implements ForestBuilder {
    private int numberOfTrees = 100;
    private boolean applyBagging = false;
    private boolean applyRandomSubspaceMethod = false;
    private boolean applyAdaBoost = false;
    private boolean applySoftRestrictedRSM = false;
    private boolean applyHardRestrictedRSM = false;
    private boolean applyRandomRoot = false;
    private boolean applyLowCorrelationBagging = false;
    private boolean applyLowCorrelationRSM = false;
    private WeightType weightType = WeightType.EQUAL;
    private TieResolvingStrategy tieResolvingStrategy;
    private MurTreeBuilder murTreeBuilder;

    /**
     * Constructor for RandomForestBuilder.
     * @param maxDepth the maximum depth
     * @param maxNumberOfNodes the maximum number of nodes
     */
    public MurRandomForestBuilder(int maxDepth, int maxNumberOfNodes) {
        this.murTreeBuilder = new MurTreeBuilder()
                .withDepth(maxDepth)
                .withMaxNumberOfNodes(maxNumberOfNodes);
        this.tieResolvingStrategy = TieResolvingStrategy.HIGHESTPRIOR;
    }

    /**
     * Constructor for RandomForestBuilder with full trees.
     * @param maxDepth maximum depth
     */
    public MurRandomForestBuilder(int maxDepth) {
        this.murTreeBuilder = new MurTreeBuilder()
                .withDepth(maxDepth)
                .withMaxNumberOfNodes(pow(2, maxDepth) - 1);
        this.tieResolvingStrategy  = TieResolvingStrategy.HIGHESTPRIOR;
    }

    /**
     * Basic constructor.
     */
    public MurRandomForestBuilder() {
        this.tieResolvingStrategy  = TieResolvingStrategy.HIGHESTPRIOR;
    }

    /**
     * Sets the depth after construction of the builder.
     * @param depth depth
     * @return this
     */
    public MurRandomForestBuilder withDepth(int depth) {
        this.murTreeBuilder = new MurTreeBuilder()
                .withDepth(depth)
                .withMaxNumberOfNodes(pow(2, depth) - 1);
        return this;
    }

    /**
     * Getter for max depth.
     * @return max depth
     */
    public int getMaxDepth() {
        return murTreeBuilder.getDepth();
    }

    /**
     * Getter for max number of nodes.
     * @return max number of nodes
     */
    public int getMaxNumberOfNodes() {
        return murTreeBuilder.getNumberOfNodes();
    }


    /**
     * Sets the number of trees in the forest.
     * @param numberOfTrees desired number of trees
     * @return this
     */
    public MurRandomForestBuilder withNumberOfTrees(int numberOfTrees) {
        this.numberOfTrees = numberOfTrees;
        return this;
    }

    /**
     * Let the builder use weighted trees;
     * @return this
     */
    public MurRandomForestBuilder withWeightType(WeightType weightType) {
        this.weightType = weightType;
        return this;
    }

    /**
     * Getter for WeightType.
     * @return WeightType
     */
    public WeightType getWeightType() {
        return this.weightType;
    }

    /**
     * Apply Bootstrap Aggregating.
     * @return this
     */
    public MurRandomForestBuilder withBagging() {
        this.applyBagging = true;
        return this;
    }

    /**
     * Getter for applyBagging.
     * @return applyBagging
     */
    public boolean appliesBagging() {
        return this.applyBagging;
    }

    /**
     * Getter for applyRandomSubspaceMethod.
     * @return applyRandomSubspaceMethod
     */
    public boolean appliesRandomSubspaceMethod() {
        return this.applyRandomSubspaceMethod;
    }

    /**
     * Apply the Random Subspace Method.
     * @return this
     */
    public MurRandomForestBuilder withRandomSubspaceMethod() {
        this.applyRandomSubspaceMethod = true;
        return this;
    }

    /**
     * Randomly initialize root.
     * @return this
     */
    public MurRandomForestBuilder withRandomRoot() {
        this.applyRandomRoot = true;
        return this;
    }

    /**
     * Getter for applyRandomRoot.
     * @return applyRandomRoot
     */
    public boolean appliesRandomRoot() {
        return this.applyRandomRoot;
    }

    /**
     * Decrease correlation and bagging.
     * @return this
     */
    public MurRandomForestBuilder withLowCorrelationBagging() {
        this.applyLowCorrelationBagging = true;
        return this;
    }

    /**
     * Getter for applyLowCorrelationBagging.
     * @return applyLowCorrelationBagging
     */
    public boolean appliesLowCorrelationBagging() {
        return this.applyLowCorrelationBagging;
    }

    /**
     * Decrease correlation and RSM.
     * @return this
     */
    public MurRandomForestBuilder withLowCorrelationRSM() {
        this.applyLowCorrelationRSM = true;
        return this;
    }

    /**
     * Getter for applyLowCorrelationRSM.
     * @return applyLowCorrelationRSM
     */
    public boolean appliesLowCorrelationRSM() {
        return this.applyLowCorrelationRSM;
    }

    /**
     * Getter for applyAdaBoost.
     * @return applyAdaBoost
     */
    public boolean appliesAdaBoost() {
        return applyAdaBoost;
    }

    /**
     * Apply AdaBoost.
     * @return this
     */
    public MurRandomForestBuilder withAdaBoost() {
        this.applyAdaBoost = true;
        return this;
    }

    /**
     * Apply softRestrictedRSM.
     * @return this
     */
    public MurRandomForestBuilder withSoftRestrictedRSM() {
        this.applySoftRestrictedRSM = true;
        return this;
    }

    /**
     * Getter for applySoftRestrictedRSM.
     * @return applySoftRestrictedRSM
     */
    public boolean appliesSoftRestrictedRSM() {
        return this.applySoftRestrictedRSM;
    }

    /**
     * Apply hardRestrictedRSM.
     * @return this
     */
    public MurRandomForestBuilder withHardRestrictedRSM() {
        this.applyHardRestrictedRSM = true;
        return this;
    }

    /**
     * Getter for applyHardRestrictedRSM.
     * @return applyHardRestrictedRSM
     */
    public boolean appliesHardRestrictedRSM() {
        return this.applyHardRestrictedRSM;
    }

    /**
     * Getter for tieResolvingStrategy.
     * @return tieResolvingStrategy
     */
    public TieResolvingStrategy getTieResolvingStrategy() {
        return this.tieResolvingStrategy;
    }

    /**
     * Set the tie-resolving strategy (default is to pick the class with the highest prior probability).
     * @param strategy tie-resolving strategy
     * @return this
     */
    public MurRandomForestBuilder withTieResolvingStrategy(TieResolvingStrategy strategy) {
        this.tieResolvingStrategy = strategy;
        return this;
    }

    /**
     * Actually builds the forest with the configurations (that should already be set-up).
     * @param data data that will be used for training
     * @return the forest
     */
    public Forest build(DataSet data) {
        Forest r = null;
        Classifier tieResolver;

        //
        // Create the tie-resolver.
        //
        if (tieResolvingStrategy.equals(TieResolvingStrategy.TREE)) {
            tieResolver = murTreeBuilder.build(data);
        }
        else {
            tieResolver = new ClassificationNode(data.classWithHighestPrior());
        }

        //
        // Construct the tree.
        //

        try {
            double subspaceFraction = 0.5;
            if (applyBagging) {
                r = new BaggedRandomForest(data, numberOfTrees, murTreeBuilder, tieResolver, weightType);
            } else if (applyRandomSubspaceMethod) {
                r = new RSMRandomForest(data, numberOfTrees, subspaceFraction, murTreeBuilder, tieResolver, weightType);
            } else if (applyAdaBoost) {
                r = new AdaBoostedForest(data, numberOfTrees, murTreeBuilder, tieResolver);
            } else if (applySoftRestrictedRSM) {
                r = new SoftRestrictedRSMRandomForest(data, numberOfTrees, subspaceFraction, murTreeBuilder, tieResolver);
            } else if (applyHardRestrictedRSM) {
                r = new HardRestrictedRandomForest(data, numberOfTrees, murTreeBuilder, tieResolver);
            } else if (applyRandomRoot) {
                r = new RandomRootForest(data, numberOfTrees, murTreeBuilder, tieResolver);
            } else if (applyLowCorrelationBagging) {
                r = new LowCorrelationBaggedForest(data, numberOfTrees, murTreeBuilder, tieResolver);
            } else if (applyLowCorrelationRSM) {
                r = new LowCorrelationRSMForest(data, numberOfTrees, murTreeBuilder, tieResolver, subspaceFraction);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return r;
    }
}
