import Data.DataSet;
import Data.Record;
import org.javatuples.Pair;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static java.lang.Math.pow;

/**
 * Forest of Optimal Trees generated by assigning a root arbitrarily.
 */
public class RandomRootForest extends Forest {
    private final ArrayList<WeightedTree> trees;
    private final Classifier tieResolver;

    /**
     * Constructs the forest.
     * @param d training data
     * @param numberOfTrees number of trees
     * @param treeBuilder builds MurTrees
     * @param tieResolver classifier to resolve ties
     */
    public RandomRootForest(DataSet d, int numberOfTrees, MurTreeBuilder treeBuilder, Classifier tieResolver) {
        this.trees = new ArrayList<>(numberOfTrees);
        this.tieResolver = tieResolver;

        int maxDepth = treeBuilder.getDepth() - 1;
        int numOfNodes = (int)pow(2, maxDepth) - 1;

        List<Integer> allowedRoots = RSMRandomForest.generateFullSubspace(d.getNumberOfFeatures());

        for (int i = 0; i < numberOfTrees; i++) {
            if (allowedRoots.size() <= 0) break;
            Collections.shuffle(allowedRoots);
            int root = allowedRoots.remove(0);

            Pair<DataSet, DataSet> tmp = d.splitOnAttribute(root);
            DataSet iTrue = tmp.getValue0();
            DataSet iFalse = tmp.getValue1();
            DecisionTree leftTree;
            DecisionTree rightTree;

            if (iTrue.getSize() == 0 || iFalse.getSize() == 0) {
                // Try again
                i--;
                continue;
            }

            try {
                leftTree = MurTreeBuilder.optimalTree(iFalse, maxDepth, numOfNodes).getValue0();
                rightTree = MurTreeBuilder.optimalTree(iTrue, maxDepth, numOfNodes).getValue0();
            } catch (InterruptedException e) {
                e.printStackTrace();
                break;
            } catch (Infeasible e) {
                e.printStackTrace();
                i--;
                continue;
            }

            DecisionTree newTree = new PredicateNode(root, leftTree, rightTree);
            this.addTree(newTree);
        }
    }

    private synchronized void addTree(DecisionTree newTree) {
        trees.add(new WeightedTree(newTree, 1.0));
    }

    @Override
    public int classify(Record record) {
        return Classifier.majorityVote(trees, record, tieResolver);
    }

    @Override
    public int numberOfTrees() {
        return trees.size();
    }
}
